Step 1: 
 Create service account in a namespace.
 We will create a service account in a custom namespace
 Create a devops-tools namespace.
 
 --- > kubectl create namespace devops-tools
 
 Create a service account named "api-service-account" in devops-tools namespace
 
 --- > kubectl create serviceaccount api-service-account -n devops-tools
 
 or use the following manifest.
 --- >
 cat <<EOF | kubectl apply -f -
 apiVersion: v1
 kind: ServiceAccount
 metadata:
   name: api-service-account
   namespace: devops-tools
 EOF
 
 Step 2: Create a Cluster Role
 Assuming that the service account needs access to the entire cluster resources, we will create a cluster role 
 with a list of allowed access.
 
 Create a clusterRole named api-cluster-role with the following manifest file.
 ---- > 
 
 cat <<EOF | kubectl apply -f -
 ---
 apiVersion: rbac.authorization.k8s.io/v1
 kind: ClusterRole
 metadata:
   name: api-cluster-role
   namespace: devops-tools
 rules:
   - apiGroups:
         - ""
         - apps
         - autoscaling
         - batch
         - extensions
         - policy
         - rbac.authorization.k8s.io
     resources:
       - pods
       - componentstatuses
       - configmaps
       - daemonsets
       - deployments
       - events
       - endpoints
       - horizontalpodautoscalers
       - ingress
       - jobs
       - limitranges
       - namespaces
       - nodes
       - pods
       - persistentvolumes
       - persistentvolumeclaims
       - resourcequotas
       - replicasets
       - replicationcontrollers
       - serviceaccounts
       - services
     verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
 EOF
 The above YAML declaration has a ClusterRole with full access to all cluster resources.
 
 It is not recommended to create a service account with all cluster component access without any requirement.
 
 To get the list of available API resources execute the following command.
 --- > kubectl api-resources
 
 Step 3: Create a CluserRole Binding
 Now that we have the ClusterRole and service account, it needs to be mapped together.
 
 Bind the cluster-api-role to api-service-account using a RoleBinding
 
 ----- >
 
 cat <<EOF | kubectl apply -f -
 ---
 apiVersion: rbac.authorization.k8s.io/v1
 kind: ClusterRoleBinding
 metadata:
   name: api-cluster-role-binding
 subjects:
 - namespace: devops-tools 
   kind: ServiceAccount
   name: api-service-account 
 roleRef:
   apiGroup: rbac.authorization.k8s.io
   kind: ClusterRole
   name: api-cluster-role 
 EOF
 
 
 Step 4: Validate Service Account Access Using kubectl.
 To validate the clusterrole binding, we can use can-i commands to validate the API access assuming a service account in a specific namespace.
 
 For example, the following command checks if the api-service-account in the devops-tools namespace can list the pods.
 --- >
 
 kubectl auth can-i get pods --as=system:serviceaccount:devops-tools:api-service-account
 Here is another example, to check if the service account has permissions to delete deployments.
 ---> 
 kubectl auth can-i delete deployments --as=system:serviceaccount:devops-tools:api-service-account
 Step 5: Associate a Secret With Service Account
 To use a service account with an HTTP call, you need to have the long lived token associated with the service account.
  A long-lived token in Kubernetes is an authentication token that does not expire quickly, allowing continuous access to the Kubernetes API for an extended period.
 
 For that, you need to create a secret for the service account.
 
 Create a file named sa-token.yaml, and copy the following content.
 ---> 
 apiVersion: v1
 kind: Secret
 type: kubernetes.io/service-account-token
 metadata:
   name: api-service-account-token
   namespace: devops-tools
   annotations:
     kubernetes.io/service-account.name: api-service-account
 Then, create the secret by running the following command.
 ---> 
 kubectl apply -f sa-token.yaml
 Once the secret is created, use the following command to get the base64 decoded token. It will be used as a bearer token in the API call.
 ---> 
 kubectl get secret api-service-account-token -o=jsonpath='{.data.token}' -n devops-tools | base64 --decode
